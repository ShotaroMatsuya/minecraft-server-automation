name: Unified PR Checks

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened, labeled, unlabeled]

env:
  TF_VAR_WEBHOOK_PATH: ${{ secrets.WEBHOOK_PATH }}
  TF_VAR_github_token: ${{ secrets.TF_VAR_github_token }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  TERRAGRUNT_VERSION: 0.67.16
  TERRAFORM_VERSION: 1.9.8

permissions:
  id-token: write
  contents: read
  pull-requests: write
  security-events: write

jobs:
  check-targets:
    name: Check Target Environments
    runs-on: ubuntu-latest
    outputs:
      should_run_keeping: ${{ steps.check-labels.outputs.should_run_keeping }}
      should_run_scheduling: ${{ steps.check-labels.outputs.should_run_scheduling }}
      should_run_checks: ${{ steps.check-labels.outputs.should_run_checks }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Check PR Labels
        id: check-labels
        uses: actions/github-script@v7
        with:
          script: |
            const environmentTargetChecker = require('./scripts/github-actions/environment-target-checker.js');
            
            const result = await environmentTargetChecker(github, context);
            
            core.setOutput('should_run_keeping', result.should_run_keeping);
            core.setOutput('should_run_scheduling', result.should_run_scheduling);
            core.setOutput('should_run_checks', result.should_run_checks);

  security-scan:
    name: Infrastructure Security Scan
    runs-on: ubuntu-latest
    needs: [check-targets]
    if: needs.check-targets.outputs.should_run_checks == 'true'
    outputs:
      has_issues: ${{ steps.check-results.outputs.has_issues }}
      results_summary: ${{ steps.check-results.outputs.results_summary }}
      scan_status: ${{ steps.check-results.outputs.scan_status }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup aqua
        uses: aquaproj/aqua-installer@v3.0.1
        with:
          aqua_version: v2.30.0

      - name: Install tools via aqua
        run: |
          rm -f ./terragrunt ./terraform ./tflint ./aws ./jq ./yq 2>/dev/null || true
          aqua install --all

      - name: Check if terraform directory exists
        id: check-terraform
        run: |
          if [ -d "terraform" ]; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Run Trivy Security Scan
        id: trivy-scan
        if: steps.check-terraform.outputs.exists == 'true'
        run: |
          echo "🔍 Running Trivy security scan..."
          
          # Run Trivy scan and capture errors
          scan_exit_code=0
          trivy config terraform/ \
            --config trivy.yaml \
            --format table \
            --output trivy-results.txt \
            --exit-code 0 2> trivy-errors.txt || scan_exit_code=$?
          
          # Generate SARIF for GitHub Security tab
          trivy config terraform/ \
            --config trivy.yaml \
            --format sarif \
            --output trivy-security.sarif \
            --exit-code 0 || true
          
          # Set scan status
          if [ $scan_exit_code -eq 0 ]; then
            echo "scan_status=success" >> "$GITHUB_OUTPUT"
          else
            echo "scan_status=failed" >> "$GITHUB_OUTPUT"
          fi

      - name: Check Security Results
        id: check-results
        run: |
          if [ "${{ steps.trivy-scan.outputs.scan_status }}" = "failed" ]; then
            echo "has_issues=false" >> "$GITHUB_OUTPUT"
            echo "results_summary=Security scan failed" >> "$GITHUB_OUTPUT"
            echo "scan_status=failed" >> "$GITHUB_OUTPUT"
          elif [ -f "trivy-results.txt" ] && [ -s "trivy-results.txt" ]; then
            if grep -q -E "(CRITICAL|HIGH|MEDIUM)" trivy-results.txt 2>/dev/null; then
              echo "has_issues=true" >> "$GITHUB_OUTPUT"
              echo "results_summary=Security issues found" >> "$GITHUB_OUTPUT"
              echo "scan_status=success" >> "$GITHUB_OUTPUT"
            else
              echo "has_issues=false" >> "$GITHUB_OUTPUT"
              echo "results_summary=No security issues found" >> "$GITHUB_OUTPUT"
              echo "scan_status=success" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "has_issues=false" >> "$GITHUB_OUTPUT"
            echo "results_summary=No security issues found" >> "$GITHUB_OUTPUT"
            echo "scan_status=success" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload Security Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: trivy-security-results
          path: |
            trivy-results.txt
            trivy-security.sarif
            trivy-errors.txt
          retention-days: 30

      - name: Upload SARIF to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-security.sarif'
          category: 'infrastructure-security-scan'
        if: hashFiles('trivy-security.sarif') != ''

  code-quality:
    name: TFLint Code Quality
    runs-on: ubuntu-latest
    needs: [check-targets]
    if: needs.check-targets.outputs.should_run_checks == 'true'
    outputs:
      has_issues: ${{ steps.check-results.outputs.has_issues }}
      results_summary: ${{ steps.check-results.outputs.results_summary }}
      scan_status: ${{ steps.check-results.outputs.scan_status }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup aqua
        uses: aquaproj/aqua-installer@v3.0.1
        with:
          aqua_version: v2.30.0

      - name: Install tools via aqua
        run: |
          rm -f ./terragrunt ./terraform ./tflint ./aws ./jq ./yq 2>/dev/null || true
          aqua install --all

      - name: Check if terraform directory exists
        id: check-terraform
        run: |
          if [ -d "terraform" ]; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Initialize TFLint
        if: steps.check-terraform.outputs.exists == 'true'
        run: |
          if [ -d "terraform" ]; then
            cd terraform
            tflint --init --config=../.tflint.hcl || echo "TFLint init failed - continuing without plugins"
            cd ..
          fi

      - name: Run TFLint Analysis
        id: tflint-scan
        if: steps.check-terraform.outputs.exists == 'true'
        run: |
          echo "🔍 Running TFLint code quality analysis..."
          
          scan_exit_code=0
          cd terraform
          tflint --format=compact --config=../.tflint.hcl > ../tflint-results.txt 2> ../tflint-errors.txt || scan_exit_code=$?
          cd ..
          
          # Set scan status
          if [ $scan_exit_code -eq 0 ] || [ $scan_exit_code -eq 2 ]; then
            echo "scan_status=success" >> "$GITHUB_OUTPUT"
          else
            echo "scan_status=failed" >> "$GITHUB_OUTPUT"
          fi

      - name: Check Code Quality Results
        id: check-results
        run: |
          if [ "${{ steps.tflint-scan.outputs.scan_status }}" = "failed" ]; then
            echo "has_issues=false" >> "$GITHUB_OUTPUT"
            echo "results_summary=Code quality scan failed" >> "$GITHUB_OUTPUT"
            echo "scan_status=failed" >> "$GITHUB_OUTPUT"
          elif [ -f "tflint-results.txt" ] && [ -s "tflint-results.txt" ]; then
            echo "has_issues=true" >> "$GITHUB_OUTPUT"
            echo "results_summary=Code quality issues found" >> "$GITHUB_OUTPUT"
            echo "scan_status=success" >> "$GITHUB_OUTPUT"
          else
            echo "has_issues=false" >> "$GITHUB_OUTPUT"
            echo "results_summary=No code quality issues found" >> "$GITHUB_OUTPUT"
            echo "scan_status=success" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload Code Quality Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: tflint-quality-results
          path: |
            tflint-results.txt
            tflint-errors.txt
          retention-days: 30

  terragrunt-plan:
    name: Terragrunt Plan
    runs-on: ubuntu-latest
    needs: [check-targets]
    if: needs.check-targets.outputs.should_run_checks == 'true'
    strategy:
      matrix:
        environment: [keeping, scheduling]
        include:
          - environment: keeping
            path: terragrunt/environments/keeping
          - environment: scheduling
            path: terragrunt/environments/scheduling
    outputs:
      plan_status_keeping: ${{ steps.set-keeping-output.outputs.status }}
      plan_status_scheduling: ${{ steps.set-scheduling-output.outputs.status }}
    steps:
      - name: Check if this environment should run
        id: should-run
        run: |
          # Get target labels from the check-targets job outputs
          keeping_target="${{ needs.check-targets.outputs.should_run_keeping }}"
          scheduling_target="${{ needs.check-targets.outputs.should_run_scheduling }}"
          
          # Determine if current matrix environment should run
          if [ "${{ matrix.environment }}" = "keeping" ]; then
            should_run="$keeping_target"
          elif [ "${{ matrix.environment }}" = "scheduling" ]; then
            should_run="$scheduling_target"
          else
            should_run="false"
          fi
          
          echo "should_run=$should_run" >> "$GITHUB_OUTPUT"
          echo "🎯 Environment: ${{ matrix.environment }}"
          echo "🎯 Should run: $should_run"
          
          if [ "$should_run" != "true" ]; then
            echo "⏭️ Skipping ${{ matrix.environment }} environment - not targeted by labels"
          else
            echo "🚀 Running ${{ matrix.environment }} environment"
          fi

      - name: Checkout
        if: steps.should-run.outputs.should_run == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Configure AWS Credentials
        if: steps.should-run.outputs.should_run == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/minecraft-test-github-actions
          role-session-name: github-actions-test-session
          aws-region: ap-northeast-1

      - name: Setup aqua
        if: steps.should-run.outputs.should_run == 'true'
        uses: aquaproj/aqua-installer@v3.0.1
        with:
          aqua_version: v2.30.0

      - name: Install tools via aqua
        if: steps.should-run.outputs.should_run == 'true'
        run: |
          rm -f ./terragrunt ./terraform ./tflint ./aws ./jq ./yq 2>/dev/null || true
          aqua install --all

      - name: Setup Python 3.13
        if: steps.should-run.outputs.should_run == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Verify Python Installation
        if: steps.should-run.outputs.should_run == 'true'
        run: |
          echo "Python version: $(python3 --version)"
          echo "Python executable path: $(which python3)"
          echo "Lambda packaging will use this Python interpreter"

      - name: Check if environment exists
        if: steps.should-run.outputs.should_run == 'true'
        id: check-env
        run: |
          if [ -d "${{ matrix.path }}" ]; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create Mapping Yaml for scheduling
        if: steps.should-run.outputs.should_run == 'true' && matrix.environment == 'scheduling'
        working-directory: terraform/scheduling
        run: |
          cat << EOF > secrets.yaml
          OPS: ${{ secrets.WHITELIST_PLAYERS }}
          WHITELIST: ${{ secrets.WHITELIST_PLAYERS }}
          WEBHOOK_PATH: ${{ secrets.WEBHOOK_PATH }}
          S3_BUCKET_NAME: ${{ secrets.S3_BUCKET_NAME }}
          S3_PREFIX_NAME: ${{ secrets.S3_PREFIX_NAME }}
          FILTERING_STRINGS: ${{ secrets.FILTERING_STRINGS }}
          EOF

      - name: Terragrunt Format Check
        id: fmt-check
        if: steps.should-run.outputs.should_run == 'true' && steps.check-env.outputs.exists == 'true'
        run: |
          cd "${{ matrix.path }}"
          format_exit_code=0
          
          # Run format check and capture output
          if terragrunt fmt --check --terragrunt-non-interactive 2>&1; then
            echo "status=success" >> "$GITHUB_OUTPUT"
            # Create empty error file for consistency
            touch format_errors.txt
          else
            format_exit_code=$?
            echo "status=needs_formatting" >> "$GITHUB_OUTPUT"
            # Capture actual error for failed format check
            terragrunt fmt --check --terragrunt-non-interactive > /dev/null 2> format_errors.txt || true
          fi
          
          # Debug output
          echo "Format check exit code: $format_exit_code"
          echo "Format errors file size: $(wc -c < format_errors.txt 2>/dev/null || echo 0) bytes"
        continue-on-error: true

      - name: Terragrunt Validation
        id: validate
        if: steps.should-run.outputs.should_run == 'true' && steps.check-env.outputs.exists == 'true'
        run: |
          cd "${{ matrix.path }}"
          validate_exit_code=0
          
          # Run validation and capture output
          if terragrunt validate --terragrunt-non-interactive 2>&1; then
            echo "status=success" >> "$GITHUB_OUTPUT"
            # Create empty error file for consistency
            touch validate_errors.txt
          else
            validate_exit_code=$?
            echo "status=failed" >> "$GITHUB_OUTPUT"
            # Capture actual error for failed validation
            terragrunt validate --terragrunt-non-interactive > /dev/null 2> validate_errors.txt || true
          fi
          
          # Debug output
          echo "Validation exit code: $validate_exit_code"
          echo "Validation errors file size: $(wc -c < validate_errors.txt 2>/dev/null || echo 0) bytes"
        continue-on-error: true

      - name: Terragrunt Plan
        id: plan
        if: steps.should-run.outputs.should_run == 'true' && steps.check-env.outputs.exists == 'true'
        run: |
          cd "${{ matrix.path }}"
          
          # Initialize first
          init_exit_code=0
          terragrunt init --terragrunt-non-interactive 2>&1 | tee init_output.txt || init_exit_code=$?
          
          if [ $init_exit_code -ne 0 ]; then
            echo "status=init_failed" >> "$GITHUB_OUTPUT"
            echo "resources_to_add=0" >> "$GITHUB_OUTPUT"
            echo "resources_to_change=0" >> "$GITHUB_OUTPUT"
            echo "resources_to_destroy=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Run plan - capture all output as Terragrunt outputs plan to stderr
          # Generate tfplan file for potential reuse in apply stage
          plan_exit_code=0
          terragrunt plan -detailed-exitcode --terragrunt-non-interactive -out=tfplan > plan_output.txt 2>&1 || plan_exit_code=$?
          
          # Create empty error file for consistency
          touch plan_errors.txt
          
          # Parse results and set resource counts
          if [ -f "plan_output.txt" ]; then
            to_add=$(grep -c "will be created" plan_output.txt 2>/dev/null) || to_add=0
            to_change=$(grep -c "will be updated" plan_output.txt 2>/dev/null) || to_change=0
            to_destroy=$(grep -c "will be destroyed" plan_output.txt 2>/dev/null) || to_destroy=0
            
            echo "resources_to_add=$to_add" >> "$GITHUB_OUTPUT"
            echo "resources_to_change=$to_change" >> "$GITHUB_OUTPUT"
            echo "resources_to_destroy=$to_destroy" >> "$GITHUB_OUTPUT"
          else
            echo "resources_to_add=0" >> "$GITHUB_OUTPUT"
            echo "resources_to_change=0" >> "$GITHUB_OUTPUT"
            echo "resources_to_destroy=0" >> "$GITHUB_OUTPUT"
          fi
          
          # Determine status based on terraform plan -detailed-exitcode behavior
          plan_status="unknown"
          
          if [ -f "plan_output.txt" ] && grep -q "Plan:" plan_output.txt; then
            # We have a valid plan summary - extract resource counts
            to_add_check=$(grep -o "[0-9]\+ to add" plan_output.txt | grep -o "[0-9]\+" | head -1) || to_add_check=0
            to_change_check=$(grep -o "[0-9]\+ to change" plan_output.txt | grep -o "[0-9]\+" | head -1) || to_change_check=0
            to_destroy_check=$(grep -o "[0-9]\+ to destroy" plan_output.txt | grep -o "[0-9]\+" | head -1) || to_destroy_check=0
            
            # If we have a valid plan, determine status based on resource changes
            if [ "$to_add_check" -gt 0 ] || [ "$to_change_check" -gt 0 ] || [ "$to_destroy_check" -gt 0 ]; then
              plan_status="has_changes"
              echo "✅ Plan successful: $to_add_check to add, $to_change_check to change, $to_destroy_check to destroy"
            else
              plan_status="no_changes"
              echo "✅ Plan successful: No changes detected"
            fi
          elif [ "${plan_exit_code:-0}" -eq 0 ]; then
            # Exit code 0: No changes (standard terraform behavior)
            plan_status="no_changes"
            echo "✅ Plan completed: No changes"
          elif [ "${plan_exit_code:-0}" -eq 2 ]; then
            # Exit code 2: Changes detected (standard terraform behavior)
            plan_status="has_changes"
            echo "✅ Plan completed: Changes detected"
          else
            # Exit code 1 or other: Error occurred and no valid plan found
            plan_status="failed"
            echo "❌ Plan failed: Exit code ${plan_exit_code:-0}, no valid plan output"
          fi
          
          # Set the status output
          echo "status=$plan_status" >> "$GITHUB_OUTPUT"
          
          # Debug output
          echo "Plan exit code: ${plan_exit_code:-0}"
          echo "Plan output file exists: $(test -f plan_output.txt && echo 'yes' || echo 'no')"
          echo "Plan output size: $(wc -c < plan_output.txt 2>/dev/null || echo 0) bytes"
          echo "Plan errors file exists: $(test -f plan_errors.txt && echo 'yes' || echo 'no')"
          echo "Plan errors size: $(wc -c < plan_errors.txt 2>/dev/null || echo 0) bytes"
        continue-on-error: true

      - name: Set keeping-specific output
        id: set-keeping-output
        if: matrix.environment == 'keeping'
        run: |
          if [ "${{ steps.should-run.outputs.should_run }}" = "true" ]; then
            echo "status=${{ steps.plan.outputs.status }}" >> "$GITHUB_OUTPUT"
          else
            echo "status=skipped" >> "$GITHUB_OUTPUT"
          fi

      - name: Set scheduling-specific output
        id: set-scheduling-output
        if: matrix.environment == 'scheduling'
        run: |
          if [ "${{ steps.should-run.outputs.should_run }}" = "true" ]; then
            echo "status=${{ steps.plan.outputs.status }}" >> "$GITHUB_OUTPUT"
          else
            echo "status=skipped" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload Plan Results
        uses: actions/upload-artifact@v4
        if: always() && steps.should-run.outputs.should_run == 'true'
        with:
          name: terragrunt-plan-${{ matrix.environment }}
          path: |
            ${{ matrix.path }}/plan_output.txt
            ${{ matrix.path }}/init_output.txt
            ${{ matrix.path }}/plan_errors.txt
            ${{ matrix.path }}/format_errors.txt
            ${{ matrix.path }}/validate_errors.txt
            ${{ matrix.path }}/tfplan
          retention-days: 30

  comment-results:
    name: Comment PR Results
    runs-on: ubuntu-latest
    needs: [check-targets, security-scan, code-quality, terragrunt-plan]
    if: always() && needs.check-targets.outputs.should_run_checks == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Security Results
        uses: actions/download-artifact@v4
        with:
          name: trivy-security-results
          path: security-results/
        continue-on-error: true

      - name: Comment Security Scan Results
        if: needs.security-scan.result != 'skipped'
        uses: actions/github-script@v7
        with:
          script: |
            const commentHandler = require('./scripts/github-actions/comment-handler.js');
            
            const inputs = {
              commentType: 'security',
              hasIssues: '${{ needs.security-scan.outputs.has_issues }}' === 'true',
              resultsSummary: '${{ needs.security-scan.outputs.results_summary }}' || 'No security issues found',
              scanStatus: '${{ needs.security-scan.outputs.scan_status }}' || 'success',
              errorLogPath: 'security-results/trivy-errors.txt'
            };
            
            await commentHandler(github, context, inputs);

      - name: Download Code Quality Results
        uses: actions/download-artifact@v4
        with:
          name: tflint-quality-results
          path: quality-results/
        continue-on-error: true

      - name: Comment Code Quality Results
        if: needs.code-quality.result != 'skipped'
        uses: actions/github-script@v7
        with:
          script: |
            const commentHandler = require('./scripts/github-actions/comment-handler.js');
            
            const inputs = {
              commentType: 'code-quality',
              hasIssues: '${{ needs.code-quality.outputs.has_issues }}' === 'true',
              resultsSummary: '${{ needs.code-quality.outputs.results_summary }}' || 'No code quality issues found',
              scanStatus: '${{ needs.code-quality.outputs.scan_status }}' || 'success',
              errorLogPath: 'quality-results/tflint-errors.txt'
            };
            
            await commentHandler(github, context, inputs);

      - name: Download Terragrunt Plan Results
        id: download-artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: terragrunt-plan-*
          path: plan-results/
          merge-multiple: false
        continue-on-error: true

      - name: Check Downloaded Artifacts
        id: check-artifacts
        run: |
          echo "🔍 Checking for downloaded plan artifacts..."
          
          # Check if plan-results directory exists and has content
          if [ -d "plan-results" ] && [ "$(find plan-results/ -type f 2>/dev/null | wc -l)" -gt 0 ]; then
            echo "artifacts_found=true" >> "$GITHUB_OUTPUT"
            echo "✅ Plan artifacts found"
            
            # List found artifacts for transparency
            echo "📁 Found artifacts:"
            find plan-results/ -type f -name "*.txt" -exec basename {} \; | sort | uniq | sed 's/^/  - /'
          else
            echo "artifacts_found=false" >> "$GITHUB_OUTPUT"
            echo "⚠️ No plan artifacts found - environments may have been skipped"
          fi

      - name: Comment Terragrunt Plan Results
        if: needs.terragrunt-plan.result != 'skipped'
        uses: actions/github-script@v7
        with:
          script: |
            const commentHandler = require('./scripts/github-actions/comment-handler.js');
            
            // Check if we have any artifacts to process
            const artifactsFound = '${{ steps.check-artifacts.outputs.artifacts_found }}' === 'true';
            
            if (!artifactsFound) {
              console.log('ℹ️ No plan artifacts found - likely all environments were skipped by label targeting');
              
              // Still post a comment to inform about the skipped state
              const inputs = {
                commentType: 'terragrunt-plan-summary',
                message: 'All Terragrunt environments were skipped based on PR labels. No plan execution was performed.',
                artifactBasePath: 'plan-results'
              };
              
              await commentHandler(github, context, inputs);
              return;
            }
            
            // Process both environments if artifacts are available
            const environments = [
              {
                name: 'keeping',
                status: '${{ needs.terragrunt-plan.outputs.plan_status_keeping }}'
              },
              {
                name: 'scheduling', 
                status: '${{ needs.terragrunt-plan.outputs.plan_status_scheduling }}'
              }
            ];
            
            for (const env of environments) {
              // Skip if the status is 'skipped' (environment was not targeted)
              if (env.status === 'skipped') {
                console.log(`⏭️ Skipping ${env.name} environment - not targeted by labels`);
                continue;
              }
              
              console.log(`🔄 Processing ${env.name} environment...`);
              
              const inputs = {
                commentType: 'terragrunt-plan',
                environment: env.name,
                status: env.status || 'unknown',
                planFilePath: `plan-results/terragrunt-plan-${env.name}/plan_output.txt`,
                initErrorLogPath: `plan-results/terragrunt-plan-${env.name}/init_output.txt`,
                planErrorLogPath: `plan-results/terragrunt-plan-${env.name}/plan_errors.txt`,
                formatErrorLogPath: `plan-results/terragrunt-plan-${env.name}/format_errors.txt`,
                validateErrorLogPath: `plan-results/terragrunt-plan-${env.name}/validate_errors.txt`,
                artifactBasePath: 'plan-results'
              };
              
              try {
                await commentHandler(github, context, inputs);
                console.log(`✅ Successfully processed ${env.name} environment`);
              } catch (error) {
                console.error(`❌ Error processing ${env.name} environment:`, error);
                // Continue processing other environments even if one fails
              }
            }
