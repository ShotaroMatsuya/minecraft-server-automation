name: Auto Label PR by Environment

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'terragrunt/**'
      - 'terraform/**'

permissions:
  pull-requests: write
  contents: read

jobs:
  auto-label:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            terragrunt/**
            terraform/**

      - name: Analyze changes and set labels
        uses: actions/github-script@v7
        with:
          script: |
            const changedFiles = `${{ steps.changed-files.outputs.all_changed_files }}`.split(' ').filter(f => f);
            console.log('Changed files:', changedFiles);
            
            // Analyze which environments are affected
            const keepingFiles = changedFiles.filter(file => 
              file.includes('terragrunt/environments/keeping/') || 
              file.includes('terraform/keeping/')
            );
            
            const schedulingFiles = changedFiles.filter(file => 
              file.includes('terragrunt/environments/scheduling/') || 
              file.includes('terraform/scheduling/')
            );
            
            console.log('Keeping files:', keepingFiles);
            console.log('Scheduling files:', schedulingFiles);
            
            // Get current labels
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const currentLabelNames = currentLabels.map(label => label.name);
            console.log('Current labels:', currentLabelNames);
            
            // Determine required labels
            const requiredLabels = [];
            if (keepingFiles.length > 0) {
              requiredLabels.push('target:keeping');
            }
            if (schedulingFiles.length > 0) {
              requiredLabels.push('target:scheduling');
            }
            
            console.log('Required labels:', requiredLabels);
            
            // Remove old target labels that are no longer needed
            const targetLabelsToRemove = currentLabelNames.filter(label => 
              label.startsWith('target:') && !requiredLabels.includes(label)
            );
            
            for (const labelToRemove of targetLabelsToRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: labelToRemove
                });
                console.log(`Removed label: ${labelToRemove}`);
              } catch (error) {
                console.log(`Failed to remove label ${labelToRemove}:`, error.message);
              }
            }
            
            // Add new required labels
            const labelsToAdd = requiredLabels.filter(label => !currentLabelNames.includes(label));
            
            if (labelsToAdd.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: labelsToAdd
                });
                console.log(`Added labels: ${labelsToAdd.join(', ')}`);
              } catch (error) {
                console.log(`Failed to add labels:`, error.message);
              }
            }
            
            // Create summary comment
            if (requiredLabels.length > 0) {
              const summary = `## üè∑Ô∏è Environment Detection Results
            
            **Detected Infrastructure Changes:**
            ${keepingFiles.length > 0 ? `
            ### üè† Keeping Environment
            - **Files changed:** ${keepingFiles.length}
            - **Label:** \`target:keeping\` ${labelsToAdd.includes('target:keeping') ? '(added)' : '(existing)'}
            
            <details>
            <summary>Changed files</summary>
            
            ${keepingFiles.map(f => `- \`${f}\``).join('\n')}
            </details>` : ''}
            ${schedulingFiles.length > 0 ? `
            ### ‚è∞ Scheduling Environment  
            - **Files changed:** ${schedulingFiles.length}
            - **Label:** \`target:scheduling\` ${labelsToAdd.includes('target:scheduling') ? '(added)' : '(existing)'}
            
            <details>
            <summary>Changed files</summary>
            
            ${schedulingFiles.map(f => `- \`${f}\``).join('\n')}
            </details>` : ''}
            
            **Next Steps:**
            - üîç PR checks will run for detected environments
            - üöÄ Apply will execute for labeled environments after merge
            - üìù You can manually add/remove \`target:\` labels if needed
            
            *ü§ñ Labels updated automatically based on infrastructure changes*`;
              
              // Find existing auto-label comment
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const autoLabelIdentifier = '## üè∑Ô∏è Environment Detection Results';
              const existingComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes(autoLabelIdentifier)
              );
              
              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: summary
                });
                console.log('Updated existing auto-label comment');
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: summary
                });
                console.log('Created new auto-label comment');
              }
            }
